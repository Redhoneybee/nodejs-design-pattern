# Proxy (프록시 패턴) &#128268;
> 다른 객체에 대한 접근을 제어하는 객체

 * 다른 객체 : **대상(Subject)** 

 * 프록시와 **대상**은 동일한 인터페이스를 가지고 있다

 * 다른 인터페이스와 완전히 호환되도록 바꿀 수 있다.

 * 프록시는 가작업을 **대상**으로 전달하여 추가적인 전처리/후처리로 동작을 향상시킨다.

---

## 프록시가 유용한 상황 

 * **데이터 유효성 검사** : 프록시가 입력을 **대상**으로 전달하기 전 유효성 검사

 * **보안** : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사결과가 긍정적인 경우에만 요청을 대상으로 전달

 * **캐싱** : 프록시가 **내부 캐시를 유지**하여 데이터가 캐시에 아직 존재하지 않는 경우에만 **대상**에서 작업이 실행되도록 한다.

 * **지연 초기화** : **대상**의 생성 비용이 비싸다면 프록시는 그것을 필요로 할때까지 연기

 * **로깅** : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록

 * **원격 객체** : 프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게 함


## 구현 기술

 * 모든 매소드를 가로채기로 결정할 수도 있다.

 * 일부만 가로채고 나머지는 **직접 대상**에 위임할 수도 있다.

## 오브젝트 컴포지션
> 기능 확장, 객체가 다른 객체와 결합되는 기술

 * 프록시 패턴의 경우, **대상**과 동일한 인터페이스를 가진 새로운 객체가 작성되고 **대상**에 대한 참조가 인스턴스 변수 혹은 클로저 변수 형식으로 프록시 내부에 저장

> 참고 : Proxy.js


## 객체 증강 (몽키 패치)
> 메소드를 프록시된 구현체로 대체하여 직접 대상을 수정하는 방법 (가장 실용적인 프록시 )

```
function createProxy(subject) {
    const helloOrig = subject.hello;
    subject.hello = () => (helloOrig.call(this) + 'world');

    return subject;
}

```
> 가장 편리한 메소드지만, 객체를 직접 수정하는 단점 존재

## 팩토리 함수를 사용하여 프록시를 생성하면 사용된 기술로부터 코드 보호 가능
